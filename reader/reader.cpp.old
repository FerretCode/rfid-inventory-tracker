#include "hardware/spi.h"
#include "pico/stdlib.h"
#include <stdio.h>

// MFRC Config
#define SPI_PORT spi0
#define MFRC_RST 20
#define MFRC_CS 17
#define MFRC_SCK 18
#define MFRC_MOSI 16
#define MFRC_MISO 19

// MFRC Registers
#define CommandReg 0x01
#define ComIrqReg 0x04
#define ModeReg 0x11
#define TxModeReg 0x12
#define RxModeReg 0x13
#define TxControlReg 0x14
#define BitFramingReg 0x0D
#define CollReg 0x0E
#define Status1Reg 0x07
#define Status2Reg 0x08
#define FIFODataReg 0x09
#define FIFOLevelReg 0x0A

// MFRC Commands
#define PCD_IDLE 0x00
#define PCD_TRANSCEIVE 0x0C
#define PCD_SOFTRESET 0x0F

// MFRC Error Codes
#define MI_OK 0
#define MI_ERR 1

// MFRC Request Modes
#define PICC_REQIDL 0x26
#define PICC_REQALL 0x52

// MFRC Tag Types
#define PICC_TYPE_MIFARE_MINI 0x00
#define PICC_TYPE_MIFARE_1K 0x01
#define PICC_TYPE_MIFARE_4K 0x02
#define PICC_TYPE_MIFARE_UL 0x04
#define PICC_TYPE_MIFARE_PLUS 0x08
#define PICC_TYPE_UNKNOWN 0xFF

/**
 * Write a byte to a specific MFRC register
 * It takes the register to write to, and the byte to write
 */
void mfrc_write(uint8_t reg, uint8_t value)
{
    uint8_t buf[2];
    buf[0] = (reg << 1) & 0x7E;
    buf[1] = value;

    gpio_put(MFRC_CS, 0);
    spi_write_blocking(SPI_PORT, buf, 2);
    gpio_put(MFRC_CS, 1);
}

/**
 * Read a byte from a specified MFRC register
 * Takes the register and returns the output byte
 */
uint8_t mfrc_read(uint8_t reg)
{
    uint8_t buf[2];
    buf[0] = ((reg << 1) & 0x7E) | 0x80;
    buf[1] = 0;

    gpio_put(MFRC_CS, 0);
    spi_write_read_blocking(SPI_PORT, buf, buf, 2);
    gpio_put(MFRC_CS, 1);

    return buf[1];
}

/**
 * Initialize the MFRC module over SPI
 */
void mfrc_init()
{
    // Initialize GPIO pins
    gpio_set_function(MFRC_SCK, GPIO_FUNC_SPI);
    gpio_set_function(MFRC_MISO, GPIO_FUNC_SPI);
    gpio_set_function(MFRC_MOSI, GPIO_FUNC_SPI);

    gpio_init(MFRC_CS);
    gpio_set_dir(MFRC_CS, GPIO_OUT);
    gpio_put(MFRC_CS, 1);

    gpio_init(MFRC_RST);
    gpio_set_dir(MFRC_RST, GPIO_OUT);
    gpio_put(MFRC_RST, 1);

    // Soft reset
    mfrc_write(CommandReg, PCD_SOFTRESET);
    sleep_ms(50);

    // Verify version
    uint8_t version = mfrc_read(0x37);
    printf("MFRC522 Version: 0x%02X\n", version);

    // Configure protocol
    mfrc_write(TxModeReg, 0x00);
    mfrc_write(RxModeReg, 0x00);

    // Configure antenna
    mfrc_write(TxControlReg, 0x83); // Enable antenna

    // Set default mode
    mfrc_write(ModeReg, 0x3D);

    mfrc_write(RxModeReg, 0x1D);
    mfrc_write(TxModeReg, 0x1D);

    mfrc_write(BitFramingReg, 0x07);

    mfrc_write(ComIrqReg, 0x7F);
}

void read_mfrc_error()
{
    uint8_t error_result = mfrc_read(0x06);

    printf("Error byte result: 0x%02x\n", error_result);
}

/**
 * Check if a tag is present in front of the antenna from the MFRC module
 */
uint8_t mfrc_request(uint8_t req_mode, uint8_t* tag_type)
{
    mfrc_write(ComIrqReg, 0x7F);
    mfrc_write(FIFOLevelReg, 0x80);
    mfrc_write(CommandReg, PCD_IDLE);

    uint8_t buffer[2];
    buffer[0] = req_mode;

    printf("Request Preparation:\n");
    printf("Command Reg Before: 0x%02X\n", mfrc_read(CommandReg));
    printf("Status1 Reg: 0x%02X\n", mfrc_read(Status1Reg));
    printf("Status2 Reg: 0x%02X\n", mfrc_read(Status2Reg));

    mfrc_write(CommandReg, PCD_TRANSCEIVE);
    mfrc_write(FIFODataReg, buffer[0]);
    mfrc_write(BitFramingReg, 0x80);

    uint16_t timeout = 2000;
    while (timeout--) {
        uint8_t status1 = mfrc_read(Status1Reg);
        uint8_t status2 = mfrc_read(Status2Reg);
        uint8_t irq_status = mfrc_read(ComIrqReg);

        printf("Status 1: 0x%02x, Status 2: 0x%02x, IRQ Status: 0x%02x\n", status1, status2, irq_status);
        read_mfrc_error();

        if (irq_status & 0x30) {
            uint8_t fifo_level = mfrc_read(FIFOLevelReg);

            if (fifo_level > 0) {
                mfrc_write(FIFOLevelReg, 0x80);

                buffer[0] = mfrc_read(FIFODataReg);
                buffer[1] = mfrc_read(FIFODataReg);

                if (tag_type != NULL) {
                    tag_type[0] = buffer[0];
                    tag_type[1] = buffer[1];
                }

                return MI_OK;
            }
        }

        sleep_ms(1);
    }

    return MI_ERR;
}

void comprehensive_mfrc_debug()
{
    printf("Comprehensive MFRC522 Debug:\n");
    printf("Version: 0x%02X\n", mfrc_read(Status2Reg) & 0x07);

    printf("All Critical Registers:\n");
    uint8_t registers[] = {
        CommandReg, ComIrqReg, ModeReg,
        TxModeReg, RxModeReg, TxControlReg,
        BitFramingReg, Status1Reg, Status2Reg,
        FIFOLevelReg
    };

    for (int i = 0; i < sizeof(registers); i++) {
        printf("Reg 0x%02X: 0x%02X\n", registers[i], mfrc_read(registers[i]));
    }
}

int main()
{
    stdio_usb_init();

    sleep_ms(2000);

    printf("MFRC522 Initializing...\n");

    spi_init(SPI_PORT, 1 * 1000 * 1000);
    spi_set_format(SPI_PORT, 8, SPI_CPOL_1, SPI_CPHA_1, SPI_MSB_FIRST);
    mfrc_init();

    printf("MFRC522 Initialized. Waiting for tags...\n");

    comprehensive_mfrc_debug();

    uint8_t tag_type;
    while (1) {
        printf("Checking for tag...\n");
        int status = mfrc_request(PICC_REQIDL, &tag_type);
        printf("Status received: %d\n", status);

        if (status == MI_OK) {
            printf("Tag Type Detected: ");
            switch (tag_type) {
            case PICC_TYPE_MIFARE_UL:
                printf("MIFARE Ultralight");
                break;
            case PICC_TYPE_MIFARE_1K:
                printf("MIFARE Classic 1K");
                break;
            case PICC_TYPE_MIFARE_4K:
                printf("MIFARE Classic 4K");
                break;
            default:
                printf("Unknown Type");
                break;
            }
            printf(" (0x%02X)\n", tag_type);
        } else {
            printf("No tag detected. Status: %d\n", status);
        }
        sleep_ms(250);
    }
}
